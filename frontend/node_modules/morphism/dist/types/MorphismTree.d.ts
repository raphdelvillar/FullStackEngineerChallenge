import { Actions, Schema, StrictSchema } from './types';
export declare enum NodeKind {
    Root = "Root",
    Property = "Property",
    ActionFunction = "ActionFunction",
    ActionAggregator = "ActionAggregator",
    ActionString = "ActionString",
    ActionSelector = "ActionSelector"
}
declare type PreparedAction = (params: {
    object: any;
    items: any;
    objectToCompute: any;
}) => any;
interface SchemaNodeData<Target, Source> {
    propertyName: string;
    action: Actions<Target, Source> | null;
    preparedAction?: PreparedAction | null;
    kind: NodeKind;
    targetPropertyPath: string;
}
export interface SchemaNode<Target, Source> {
    data: SchemaNodeData<Target, Source>;
    parent: SchemaNode<Target, Source> | null;
    children: SchemaNode<Target, Source>[];
}
declare type Overwrite<T1, T2> = {
    [P in Exclude<keyof T1, keyof T2>]: T1[P];
} & T2;
declare type AddNode<Target, Source> = Overwrite<SchemaNodeData<Target, Source>, {
    kind?: NodeKind;
    targetPropertyPath?: string;
    preparedAction?: (...args: any) => any;
}>;
export interface SchemaOptions<Target = any> {
    class?: {
        automapping: boolean;
    };
    undefinedValues?: {
        strip: boolean;
        default?: (target: Target, propertyPath: string) => any;
    };
}
/**
 * A utility function that allows defining a `StrictSchema` with extra-options e.g: how to handle `undefinedValues`
 *
 * @param {StrictSchema} schema
 * @param {SchemaOptions<Target>} [options]
 */
export declare function createSchema<Target = any, Source = any>(schema: StrictSchema<Target, Source>, options?: SchemaOptions<Target>): StrictSchema<Target, Source>;
export declare class MorphismSchemaTree<Target, Source> {
    schemaOptions: SchemaOptions<Target>;
    root: SchemaNode<Target, Source>;
    schema: Schema | StrictSchema | null;
    constructor(schema: Schema<Target, Source> | StrictSchema<Target, Source> | null);
    static getSchemaOptions<Target>(schema: Schema | StrictSchema | null): SchemaOptions<Target>;
    private parseSchema;
    traverseBFS(): IterableIterator<SchemaNode<Target, Source>>;
    add(data: AddNode<Target, Source>, targetPropertyPath?: string): void;
    getActionKind(action: Actions<Target, Source> | null): NodeKind.Property | NodeKind.ActionFunction | NodeKind.ActionAggregator | NodeKind.ActionString | NodeKind.ActionSelector | undefined;
    getPreparedAction(nodeData: SchemaNodeData<Target, Source>): PreparedAction | null;
}
export {};
