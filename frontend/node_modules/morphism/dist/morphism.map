{"version":3,"sources":["webpack://Morphism/webpack/universalModuleDefinition","webpack://Morphism/webpack/bootstrap","webpack://Morphism/./src/helpers.ts","webpack://Morphism/./src/MorphismTree.ts","webpack://Morphism/./src/MorphismDecorator.ts","webpack://Morphism/./src/morphism.ts","webpack://Morphism/./src/MorphismRegistry.ts"],"names":["root","factory","exports","module","define","amd","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","SCHEMA_OPTIONS_SYMBOL","for","isActionSelector","isObject","isActionString","isString","isActionAggregator","Array","isArray","every","NodeKind","aggregator","paths","reduce","delta","path","set","isUndefined","undefined","type","String","isFunction","isPromise","Promise","resolve","a","replace","split","length","k","zipObject","props","values","prev","prop","_objectSpread","[object Object]","hasShallowProperty","obj","doNotReplace","map","getKey","currentPath","currentValue","getShallowProperty","slice","intKey","parseInt","toString","createSchema","schema","options","isEmptyObject","MorphismSchemaTree","constructor","schemaOptions","getSchemaOptions","data","targetPropertyPath","propertyName","action","kind","Root","parent","children","parseSchema","MorphismTree_objectSpread","class","automapping","undefinedValues","strip","partialSchema","actionKey","parentKeyPath","add","concat","forEach","subSchema","index","keys","queue","push","node","shift","getActionKind","Error","nodeToAdd","preparedAction","getPreparedAction","traverseBFS","ActionString","ActionFunction","ActionSelector","ActionAggregator","Property","nodeData","targetProperty","_ref","_ref2","items","objectToCompute","_ref3","_ref4","result","fn","e","message","decorator","mapper","_target","_name","descriptor","_len","arguments","args","_key","output","apply","then","res","transformValuesFromObject","tree","transformChunks","finalObject","chunk","finalValue","destination","source","undefinedValueCheck","default","transformItems","finalSchema","baseSchema","typeFields","defaultSchema","assign","getSchemaForClass","classObject","morphism","morph","toJSObject","toClassObject","__webpack_exports__","morphismRegistry","cache","_registry","Map","register","exists","getMapper","setMapper","deleteMapper","delete","has","mappers","morphismMixin","Morphism"],"mappings":"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","file":"morphism.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Morphism\"] = factory();\n\telse\n\t\troot[\"Morphism\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","import { ActionSelector, ActionAggregator, ActionFunction } from './types';\n\nexport const SCHEMA_OPTIONS_SYMBOL = Symbol.for('SchemaOptions');\n\nexport function isActionSelector<S, R>(value: any): value is ActionSelector<S, R> {\n  return isObject(value) && value.hasOwnProperty('fn') && value.hasOwnProperty('path');\n}\nexport function isActionString(value: any): value is string {\n  return isString(value);\n}\nexport function isActionAggregator(value: any): value is ActionAggregator {\n  return Array.isArray(value) && value.every(isActionString);\n}\nexport function isActionFunction(value: any): value is ActionFunction {\n  return isFunction(value);\n}\n\nexport function isValidAction(action: any) {\n  return isString(action) || isFunction(action) || isActionSelector(action) || isActionAggregator(action);\n}\n\nexport const aggregator = (paths: string[], object: any) => {\n  return paths.reduce((delta, path) => {\n    set(delta, path, get(object, path)); // TODO: ensure set will return the mutated object\n    return delta;\n  }, {});\n};\n\nexport function isUndefined(value: any) {\n  return value === undefined;\n}\n\nexport function isObject(value: any): value is object {\n  const type = typeof value;\n  return value != null && (type === 'object' || type === 'function');\n}\n\nexport function isString(value: any): value is string {\n  return typeof value === 'string' || value instanceof String;\n}\n\nexport function isFunction(value: any): value is (...args: any[]) => any {\n  return typeof value === 'function';\n}\n\nexport function isPromise(object: any) {\n  if (Promise && Promise.resolve) {\n    // tslint:disable-next-line:triple-equals\n    return Promise.resolve(object) == object;\n  } else {\n    throw 'Promise not supported in your environment';\n  }\n}\nexport function get(object: any, path: string) {\n  path = path.replace(/\\[(\\w+)\\]/g, '.$1'); // convert indexes to properties\n  path = path.replace(/^\\./, ''); // strip a leading dot\n  const a = path.split('.');\n  for (let i = 0, n = a.length; i < n; ++i) {\n    const k = a[i];\n    if (isObject(object) && k in object) {\n      object = (object as any)[k];\n    } else {\n      return;\n    }\n  }\n  return object;\n}\n\nexport function zipObject(props: string[], values: any[]) {\n  return props.reduce((prev, prop, i) => {\n    return { ...prev, [prop]: values[i] };\n  }, {});\n}\n\n// https://github.com/mariocasciaro/object-path/blob/master/index.js\nfunction hasOwnProperty(obj: any, prop: any) {\n  if (obj == null) {\n    return false;\n  }\n  // to handle objects with null prototypes (too edge case?)\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\nfunction hasShallowProperty(obj: any, prop: any) {\n  return (typeof prop === 'number' && Array.isArray(obj)) || hasOwnProperty(obj, prop);\n}\nfunction getShallowProperty(obj: any, prop: any) {\n  if (hasShallowProperty(obj, prop)) {\n    return obj[prop];\n  }\n}\nexport function set(obj: any, path: any, value: any, doNotReplace?: boolean): any {\n  if (typeof path === 'number') {\n    path = [path];\n  }\n  if (!path || path.length === 0) {\n    return obj;\n  }\n  if (typeof path === 'string') {\n    return set(obj, path.split('.').map(getKey), value, doNotReplace);\n  }\n  const currentPath = path[0];\n  const currentValue = getShallowProperty(obj, currentPath);\n  if (path.length === 1) {\n    if (currentValue === void 0 || !doNotReplace) {\n      obj[currentPath] = value;\n    }\n    return currentValue;\n  }\n\n  if (currentValue === void 0) {\n    // check if we assume an array\n    if (typeof path[1] === 'number') {\n      obj[currentPath] = [];\n    } else {\n      obj[currentPath] = {};\n    }\n  }\n\n  return set(obj[currentPath], path.slice(1), value, doNotReplace);\n}\n\nfunction getKey(key: any) {\n  const intKey = parseInt(key);\n  if (intKey.toString() === key) {\n    return intKey;\n  }\n  return key;\n}\n\nexport function isEmptyObject(obj: object) {\n  for (const prop in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, prop)) {\n      return false;\n    }\n  }\n  return true;\n}\n","import { Actions, Schema, StrictSchema } from './types';\nimport {\n  aggregator,\n  get,\n  isValidAction,\n  isActionString,\n  isActionSelector,\n  isActionAggregator,\n  isActionFunction,\n  isFunction,\n  isString,\n  isObject,\n  SCHEMA_OPTIONS_SYMBOL,\n  isEmptyObject\n} from './helpers';\n\nexport enum NodeKind {\n  Root = 'Root',\n  Property = 'Property',\n  ActionFunction = 'ActionFunction',\n  ActionAggregator = 'ActionAggregator',\n  ActionString = 'ActionString',\n  ActionSelector = 'ActionSelector'\n}\n\ntype PreparedAction = (params: { object: any; items: any; objectToCompute: any }) => any;\ninterface SchemaNodeData<Target, Source> {\n  propertyName: string;\n  action: Actions<Target, Source> | null;\n  preparedAction?: PreparedAction | null;\n  kind: NodeKind;\n  targetPropertyPath: string;\n}\nexport interface SchemaNode<Target, Source> {\n  data: SchemaNodeData<Target, Source>;\n  parent: SchemaNode<Target, Source> | null;\n  children: SchemaNode<Target, Source>[];\n}\n\ntype Overwrite<T1, T2> = { [P in Exclude<keyof T1, keyof T2>]: T1[P] } & T2;\n\ntype AddNode<Target, Source> = Overwrite<\n  SchemaNodeData<Target, Source>,\n  {\n    kind?: NodeKind;\n    targetPropertyPath?: string;\n    preparedAction?: (...args: any) => any;\n  }\n>;\nexport interface SchemaOptions<Target = any> {\n  class?: { automapping: boolean };\n  undefinedValues?: {\n    strip: boolean;\n    default?: (target: Target, propertyPath: string) => any;\n  };\n}\n\n/**\n * A utility function that allows defining a `StrictSchema` with extra-options e.g: how to handle `undefinedValues`\n *\n * @param {StrictSchema} schema\n * @param {SchemaOptions<Target>} [options]\n */\nexport function createSchema<Target = any, Source = any>(schema: StrictSchema<Target, Source>, options?: SchemaOptions<Target>) {\n  if (options && !isEmptyObject(options)) (schema as any)[SCHEMA_OPTIONS_SYMBOL] = options;\n  return schema;\n}\n\nexport class MorphismSchemaTree<Target, Source> {\n  schemaOptions: SchemaOptions<Target>;\n\n  root: SchemaNode<Target, Source>;\n  schema: Schema | StrictSchema | null;\n\n  constructor(schema: Schema<Target, Source> | StrictSchema<Target, Source> | null) {\n    this.schema = schema;\n    this.schemaOptions = MorphismSchemaTree.getSchemaOptions(this.schema);\n\n    this.root = {\n      data: { targetPropertyPath: '', propertyName: 'MorphismTreeRoot', action: null, kind: NodeKind.Root },\n      parent: null,\n      children: []\n    };\n    if (schema) {\n      this.parseSchema(schema);\n    }\n  }\n\n  static getSchemaOptions<Target>(schema: Schema | StrictSchema | null): SchemaOptions<Target> {\n    const defaultSchemaOptions: SchemaOptions<Target> = { class: { automapping: true }, undefinedValues: { strip: false } };\n    const options = schema ? (schema as any)[SCHEMA_OPTIONS_SYMBOL] : undefined;\n\n    return { ...defaultSchemaOptions, ...options };\n  }\n\n  private parseSchema(partialSchema: Partial<Schema | StrictSchema> | string | number, actionKey?: string, parentKeyPath?: string): void {\n    if (isValidAction(partialSchema) && actionKey) {\n      this.add({ propertyName: actionKey, action: partialSchema as Actions<Target, Source> }, parentKeyPath);\n      parentKeyPath = parentKeyPath ? `${parentKeyPath}.${actionKey}` : actionKey;\n    } else {\n      if (actionKey) {\n        // check if actionKey exists to verify if not root node\n        this.add({ propertyName: actionKey, action: null }, parentKeyPath);\n        parentKeyPath = parentKeyPath ? `${parentKeyPath}.${actionKey}` : actionKey;\n      }\n\n      if (Array.isArray(partialSchema)) {\n        partialSchema.forEach((subSchema, index) => {\n          this.parseSchema(subSchema, index.toString(), parentKeyPath);\n        });\n      } else if (isObject(partialSchema)) {\n        Object.keys(partialSchema).forEach(key => {\n          this.parseSchema((partialSchema as any)[key], key, parentKeyPath);\n        });\n      }\n    }\n  }\n\n  *traverseBFS() {\n    const queue: SchemaNode<Target, Source>[] = [];\n    queue.push(this.root);\n    while (queue.length > 0) {\n      let node = queue.shift();\n\n      if (node) {\n        for (let i = 0, length = node.children.length; i < length; i++) {\n          queue.push(node.children[i]);\n        }\n        if (node.data.kind !== NodeKind.Root) {\n          yield node;\n        }\n      } else {\n        return;\n      }\n    }\n  }\n\n  add(data: AddNode<Target, Source>, targetPropertyPath?: string) {\n    const kind = this.getActionKind(data.action);\n    if (!kind) throw new Error(`The action specified for ${data.propertyName} is not supported.`);\n\n    const nodeToAdd: SchemaNode<Target, Source> = {\n      data: { ...data, kind, targetPropertyPath: '' },\n      parent: null,\n      children: []\n    };\n    nodeToAdd.data.preparedAction = this.getPreparedAction(nodeToAdd.data);\n\n    if (!targetPropertyPath) {\n      nodeToAdd.parent = this.root;\n      nodeToAdd.data.targetPropertyPath = nodeToAdd.data.propertyName;\n      this.root.children.push(nodeToAdd);\n    } else {\n      for (const node of this.traverseBFS()) {\n        if (node.data.targetPropertyPath === targetPropertyPath) {\n          nodeToAdd.parent = node;\n          nodeToAdd.data.targetPropertyPath = `${node.data.targetPropertyPath}.${nodeToAdd.data.propertyName}`;\n          node.children.push(nodeToAdd);\n        }\n      }\n    }\n  }\n\n  getActionKind(action: Actions<Target, Source> | null) {\n    if (isActionString(action)) return NodeKind.ActionString;\n    if (isFunction(action)) return NodeKind.ActionFunction;\n    if (isActionSelector(action)) return NodeKind.ActionSelector;\n    if (isActionAggregator(action)) return NodeKind.ActionAggregator;\n    if (action === null) return NodeKind.Property;\n  }\n\n  getPreparedAction(nodeData: SchemaNodeData<Target, Source>): PreparedAction | null {\n    const { propertyName: targetProperty, action, kind } = nodeData;\n    // iterate on every action of the schema\n    if (isActionString(action)) {\n      // Action<String>: string path => [ target: 'source' ]\n      return ({ object }) => get(object, action);\n    } else if (isActionFunction(action)) {\n      // Action<Function>: Free Computin - a callback called with the current object and collection [ destination: (object) => {...} ]\n      return ({ object, items, objectToCompute }) => action.call(undefined, object, items, objectToCompute);\n    } else if (isActionAggregator(action)) {\n      // Action<Array>: Aggregator - string paths => : [ destination: ['source1', 'source2', 'source3'] ]\n      return ({ object }) => aggregator(action, object);\n    } else if (isActionSelector(action)) {\n      // Action<Object>: a path and a function: [ destination : { path: 'source', fn:(fieldValue, items) }]\n      return ({ object, items, objectToCompute }) => {\n        let result;\n        try {\n          let value;\n          if (Array.isArray(action.path)) {\n            value = aggregator(action.path, object);\n          } else if (isString(action.path)) {\n            value = get(object, action.path);\n          }\n          result = action.fn.call(undefined, value, object, items, objectToCompute);\n        } catch (e) {\n          e.message = `Unable to set target property [${targetProperty}].\n                                        \\n An error occured when applying [${action.fn.name}] on property [${action.path}]\n                                        \\n Internal error: ${e.message}`;\n          throw e;\n        }\n        return result;\n      };\n    } else if (kind === NodeKind.Property) {\n      return null;\n    } else {\n      throw new Error(`The action specified for ${targetProperty} is not supported.`);\n    }\n  }\n}\n","import { Mapper } from './types';\nimport { isPromise } from './helpers';\n\nexport function decorator<Target>(mapper: Mapper<Target>) {\n  return (_target: any, _name: string, descriptor: PropertyDescriptor) => {\n    const fn = descriptor.value;\n    if (typeof fn === 'function') {\n      descriptor.value = function(...args: any[]) {\n        const output = fn.apply(this, args);\n        if (isPromise(output)) {\n          return Promise.resolve(output).then(res => mapper(res));\n        }\n        return mapper(output);\n      };\n    }\n\n    return descriptor;\n  };\n}\n","/**\n * @module morphism\n */\nimport { zipObject, isUndefined, get, set, SCHEMA_OPTIONS_SYMBOL } from './helpers';\nimport { Schema, StrictSchema, Constructable, SourceFromSchema, Mapper, DestinationFromSchema } from './types';\nimport { MorphismSchemaTree, createSchema, SchemaOptions } from './MorphismTree';\nimport { MorphismRegistry, IMorphismRegistry } from './MorphismRegistry';\nimport { decorator } from './MorphismDecorator';\n\n/**\n * Low Level transformer function.\n * Take a plain object as input and transform its values using a specified schema.\n * @param  {Object} object\n * @param  {Map<string, string> | Map<string, Function>} schema Transformation schema\n * @param  {Array} items Items to be forwarded to Actions\n * @param  {} objectToCompute Created tranformed object of a given type\n */\nfunction transformValuesFromObject<Source, Target>(\n  object: Source,\n  tree: MorphismSchemaTree<Target, Source>,\n  items: Source[],\n  objectToCompute: Target\n) {\n  const options = tree.schemaOptions;\n  const transformChunks = [];\n\n  for (const node of tree.traverseBFS()) {\n    const { preparedAction, targetPropertyPath } = node.data;\n    if (preparedAction) transformChunks.push({ targetPropertyPath, preparedAction: preparedAction({ object, objectToCompute, items }) });\n  }\n\n  return transformChunks.reduce((finalObject, chunk) => {\n    const undefinedValueCheck = (destination: any, source: any) => {\n      // Take the Object class value property if the incoming property is undefined\n      if (isUndefined(source)) {\n        if (!isUndefined(destination)) {\n          return destination;\n        } else {\n          return; // No Black Magic Fuckery here, if the source and the destination are undefined, we don't do anything\n        }\n      } else {\n        return source;\n      }\n    };\n\n    const finalValue = undefinedValueCheck(get(finalObject, chunk.targetPropertyPath), chunk.preparedAction);\n    if (finalValue === undefined) {\n      // strip undefined values\n      if (options && options.undefinedValues && options.undefinedValues.strip) {\n        if (options.undefinedValues.default) {\n          set(finalObject, chunk.targetPropertyPath, options.undefinedValues.default(finalObject, chunk.targetPropertyPath));\n        }\n      } else {\n        // do not strip undefined values\n        set(finalObject, chunk.targetPropertyPath, finalValue);\n      }\n      return finalObject;\n    } else {\n      set(finalObject, chunk.targetPropertyPath, finalValue);\n      return finalObject;\n    }\n  }, objectToCompute);\n}\n\nfunction transformItems<T, TSchema extends Schema<T | {}>>(schema: TSchema, type?: Constructable<T>) {\n  const options = MorphismSchemaTree.getSchemaOptions<T>(schema);\n  let tree: MorphismSchemaTree<any, any>;\n  if (type && options.class && options.class.automapping) {\n    const finalSchema = getSchemaForClass(type, schema);\n    tree = new MorphismSchemaTree(finalSchema);\n  } else {\n    tree = new MorphismSchemaTree(schema);\n  }\n\n  const mapper: Mapper<TSchema> = (source: any) => {\n    if (!source) {\n      return source;\n    }\n    if (Array.isArray(source)) {\n      return source.map(obj => {\n        if (type) {\n          const classObject = new type();\n          return transformValuesFromObject(obj, tree, source, classObject);\n        } else {\n          const jsObject = {};\n          return transformValuesFromObject(obj, tree, source, jsObject);\n        }\n      });\n    } else {\n      const object = source;\n      if (type) {\n        const classObject = new type();\n        return transformValuesFromObject<any, T>(object, tree, [object], classObject);\n      } else {\n        const jsObject = {};\n        return transformValuesFromObject(object, tree, [object], jsObject);\n      }\n    }\n  };\n\n  return mapper;\n}\n\nfunction getSchemaForClass<T>(type: Constructable<T>, baseSchema: Schema<T>): Schema<T> {\n  let typeFields = Object.keys(new type());\n  let defaultSchema = zipObject(typeFields, typeFields);\n  let finalSchema = Object.assign(defaultSchema, baseSchema);\n  return finalSchema;\n}\n\n/**\n * Currying function that either outputs a mapping function or the transformed data.\n *\n * @example\n * ```js\n *\n  // => Outputs a function when only a schema is provided\n  const fn = morphism(schema);\n  const result = fn(data);\n\n  // => Outputs the transformed data when a schema and the input data is provided\n  const result = morphism(schema, data);\n\n  // => Outputs the transformed data as an ES6 Class Object when a schema, the input data and an ES6 Class are provided\n  const result = morphism(schema, data, Foo);\n  // result is type of Foo\n * ```\n * @param  {Schema} schema Structure-preserving object from a source data towards a target data\n * @param  {} items Object or Collection to be mapped\n * @param  {} type\n *\n */\nfunction morphism<\n  TSchema = Schema<DestinationFromSchema<Schema>, SourceFromSchema<Schema>>,\n  Source extends SourceFromSchema<TSchema> = SourceFromSchema<TSchema>\n>(schema: TSchema, data: Source[]): DestinationFromSchema<TSchema>[];\n\nfunction morphism<\n  TSchema = Schema<DestinationFromSchema<Schema>, SourceFromSchema<Schema>>,\n  Source extends SourceFromSchema<TSchema> = SourceFromSchema<TSchema>\n>(schema: TSchema, data: Source): DestinationFromSchema<TSchema>;\n\nfunction morphism<TSchema = Schema<DestinationFromSchema<Schema>, SourceFromSchema<Schema>>>(schema: TSchema): Mapper<TSchema>; // morphism({}) => mapper(S) => T\n\nfunction morphism<TSchema extends Schema, TDestination>(\n  schema: TSchema,\n  items: null,\n  type: Constructable<TDestination>\n): Mapper<TSchema, TDestination>; // morphism({}, null, T) => mapper(S) => T\n\nfunction morphism<\n  TSchema = Schema<DestinationFromSchema<Schema>, SourceFromSchema<Schema>>,\n  Target = never,\n  Source extends SourceFromSchema<TSchema> = SourceFromSchema<TSchema>\n>(schema: TSchema, items: Source, type: Constructable<Target>): Target; // morphism({}, {}, T) => T\n\nfunction morphism<\n  TSchema = Schema<DestinationFromSchema<Schema>, SourceFromSchema<Schema>>,\n  Target = never,\n  Source extends SourceFromSchema<TSchema> = SourceFromSchema<TSchema>\n>(schema: TSchema, items: Source[], type: Constructable<Target>): Target[]; // morphism({}, [], T) => T[]\n\nfunction morphism<Target, Source, TSchema extends Schema<Target, Source>>(\n  schema: TSchema,\n  items?: SourceFromSchema<TSchema> | null,\n  type?: Constructable<Target>\n) {\n  switch (arguments.length) {\n    case 1: {\n      return transformItems(schema);\n    }\n    case 2: {\n      return transformItems(schema)(items);\n    }\n    case 3: {\n      if (type) {\n        if (items !== null) return transformItems(schema, type)(items); // TODO: deprecate this option morphism(schema,null,Type) in favor of createSchema({},options={class: Type})\n        return transformItems(schema, type);\n      } else {\n        throw new Error(`When using morphism(schema, items, type), type should be defined but value received is ${type}`);\n      }\n    }\n  }\n}\n\n// Decorators\n/**\n * Function Decorator transforming the return value of the targeted Function using the provided Schema and/or Type\n *\n * @param {Schema<Target>} schema Structure-preserving object from a source data towards a target data\n * @param {Constructable<Target>} [type] Target Class Type\n */\nexport function morph<Target>(schema: Schema<Target>, type?: Constructable<Target>) {\n  const mapper = transformItems(schema, type);\n  return decorator(mapper);\n}\n/**\n * Function Decorator transforming the return value of the targeted Function to JS Object(s) using the provided Schema\n *\n * @param {StrictSchema<Target>} schema Structure-preserving object from a source data towards a target data\n */\nexport function toJSObject<Target>(schema: StrictSchema<Target>) {\n  const mapper = transformItems(schema);\n  return decorator(mapper);\n}\n/**\n * Function Decorator transforming the return value of the targeted Function using the provided Schema and Class Type\n *\n * @param {Schema<Target>} schema Structure-preserving object from a source data towards a target data\n * @param {Constructable<Target>} [type] Target Class Type\n */\nexport function toClassObject<Target>(schema: Schema<Target>, type: Constructable<Target>) {\n  const mapper = transformItems(schema, type);\n  return decorator(mapper);\n}\n\n// Registry\nconst morphismRegistry = new MorphismRegistry();\nconst morphismMixin: typeof morphism & any = morphism;\nmorphismMixin.register = (t: any, s: any) => morphismRegistry.register(t, s);\nmorphismMixin.map = (t: any, d: any) => morphismRegistry.map(t, d);\nmorphismMixin.getMapper = (t: any) => morphismRegistry.getMapper(t);\nmorphismMixin.setMapper = (t: any, s: any) => morphismRegistry.setMapper(t, s);\nmorphismMixin.deleteMapper = (t: any) => morphismRegistry.deleteMapper(t);\nmorphismMixin.mappers = morphismRegistry.mappers;\n\nconst Morphism: typeof morphism & IMorphismRegistry = morphismMixin;\n\nexport { morphism, createSchema, Schema, StrictSchema, SchemaOptions, Mapper, SCHEMA_OPTIONS_SYMBOL };\nexport default Morphism;\n","import { Constructable, Schema, Mapper } from './types';\nimport { morphism } from './morphism';\n\nexport interface IMorphismRegistry {\n  /**\n   * Register a mapping schema for a Class.\n   *\n   * @param type Class Type to be registered\n   * @param schema Structure-preserving object from a source data towards a target data.\n   *\n   */\n  register<Target>(type: Constructable<Target>): Mapper<Schema<Target>, Target>;\n  register<Target, TSchema>(type: Constructable<Target>, schema?: TSchema): Mapper<TSchema, Target>;\n\n  /**\n   * Transform any input in the specified Class\n   *\n   * @param {Type} type Class Type of the ouput Data\n   * @param {Object} data Input data to transform\n   *\n   */\n  map<Target>(type: Constructable<Target>): Mapper<Schema, Target>;\n  map<Target, Source>(type: Constructable<Target>, data: Source[]): Target[];\n  map<Target, Source>(type: Constructable<Target>, data: Source): Target;\n  /**\n   * Get a specific mapping function for the provided Class\n   *\n   * @param {Type} type Class Type of the ouput Data\n   *\n   */\n  getMapper<Target>(type: Constructable<Target>): Mapper<Schema, Target>;\n  /**\n   * Set a schema for a specific Class Type\n   *\n   * @param {Type} type Class Type of the ouput Data\n   * @param {Schema} schema Class Type of the ouput Data\n   *\n   */\n  setMapper<Target, TSchema extends Schema<Target>>(type: Constructable<Target>, schema: TSchema): Mapper<any, Target>;\n  /**\n   * Delete a registered schema associated to a Class\n   *\n   * @param type ES6 Class Type of the ouput Data\n   *\n   */\n  deleteMapper<Target>(type: Constructable<Target>): any;\n  /**\n   * Check if a schema has already been registered for this type\n   *\n   * @param {*} type\n   */\n  exists<Target>(type: Target): boolean;\n  /**\n   * Get the list of the mapping functions registered\n   *\n   * @param {Type} type Class Type of the ouput Data\n   *\n   */\n  mappers: Map<any, any>;\n}\n\nexport class MorphismRegistry implements IMorphismRegistry {\n  private _registry: any = null;\n  /**\n   *Creates an instance of MorphismRegistry.\n   * @param {Map<any, any>} cache Cache implementation to store the mapping functions.\n   */\n  constructor(cache?: Map<any, any> | WeakMap<any, any>) {\n    if (!cache) {\n      this._registry = { cache: new Map() };\n    } else {\n      this._registry = cache;\n    }\n  }\n\n  /**\n   * Register a mapping schema for a Class.\n   *\n   * @param type Class Type to be registered\n   * @param schema Structure-preserving object from a source data towards a target data.\n   *\n   */\n  register<Target, TSchema>(type: Constructable<Target>, schema?: TSchema) {\n    if (!type && !schema) {\n      throw new Error('type paramater is required when you register a mapping');\n    } else if (this.exists(type)) {\n      throw new Error(`A mapper for ${type.name} has already been registered`);\n    }\n    let mapper;\n    if (schema) {\n      mapper = morphism(schema, null, type);\n    } else {\n      mapper = morphism({}, null, type);\n    }\n    this._registry.cache.set(type, mapper);\n    return mapper;\n  }\n  /**\n   * Transform any input in the specified Class\n   *\n   * @param {Type} type Class Type of the ouput Data\n   * @param {Object} data Input data to transform\n   *\n   */\n  map(type: any, data?: any) {\n    if (!this.exists(type)) {\n      const mapper = this.register(type);\n      if (data === undefined) {\n        return mapper;\n      }\n    }\n    return this.getMapper(type)(data);\n  }\n  /**\n   * Get a specific mapping function for the provided Class\n   *\n   * @param {Type} type Class Type of the ouput Data\n   *\n   */\n  getMapper<Target>(type: Constructable<Target>) {\n    return this._registry.cache.get(type);\n  }\n  /**\n   * Set a schema for a specific Class Type\n   *\n   * @param {Type} type Class Type of the ouput Data\n   * @param {Schema} schema Class Type of the ouput Data\n   *\n   */\n  setMapper<Target>(type: Constructable<Target>, schema: Schema<Target>) {\n    if (!schema) {\n      throw new Error(`The schema must be an Object. Found ${schema}`);\n    } else if (!this.exists(type)) {\n      throw new Error(\n        `The type ${type.name} is not registered. Register it using \\`Mophism.register(${type.name}, schema)\\``\n      );\n    } else {\n      let fn = morphism(schema, null, type);\n      this._registry.cache.set(type, fn);\n      return fn;\n    }\n  }\n\n  /**\n   * Delete a registered schema associated to a Class\n   *\n   * @param type ES6 Class Type of the ouput Data\n   *\n   */\n  deleteMapper(type: any) {\n    return this._registry.cache.delete(type);\n  }\n\n  /**\n   * Check if a schema has already been registered for this type\n   *\n   * @param {*} type\n   */\n  exists(type: any) {\n    return this._registry.cache.has(type);\n  }\n  /**\n   * Get the list of the mapping functions registered\n   *\n   * @param {Type} type Class Type of the ouput Data\n   *\n   */\n  get mappers() {\n    return this._registry.cache as Map<any, any>;\n  }\n}\n"],"sourceRoot":""}